{"version":3,"file":"index.iife.min.js","sources":["../src/BitSet.ts","../src/BloomFilter.ts"],"sourcesContent":["type Bit = 0 | 1;\n\nexport class BitSet {\n  private readonly map: Map<number, Bit> = new Map();\n  private readonly size: number;\n\n  constructor(size: number) {\n    this.size = size;\n  }\n\n  set(position: number, value: Bit) {\n    this.map.set(position % this.size, value);\n  }\n\n  get(position: number): Bit {\n    return this.map.get(position % this.size) || 0;\n  }\n\n  toString(): string {\n    const str = [];\n\n    for (let i = 0; i < this.size; i++) {\n      str.push(this.get(i));\n    }\n\n    return str.join('');\n  }\n}\n","import { BitSet } from './BitSet';\nimport { IBloomFilter } from './IBloomFilter';\n\nexport class BloomFilter<T> implements IBloomFilter<T> {\n  private readonly bitSet: BitSet;\n\n  private readonly hash: Array<(item: T) => number>;\n\n  constructor(size: number, hash: Array<(item: T) => number>) {\n    this.bitSet = new BitSet(size);\n    this.hash = hash;\n  }\n\n  add(item: T): void {\n    this.hash.forEach(hash => {\n      this.bitSet.set(hash(item), 1);\n    });\n  }\n\n  has(item: T): boolean {\n    return !this.hash.some(hash => this.bitSet.get(hash(item)) === 0);\n  }\n}\n"],"names":["size","this","Map","BitSet","position","value","map","set","get","str","i","push","join","hash","bitSet","BloomFilter","item","forEach","_this","some"],"mappings":"+CAEA,iBAIE,WAAYA,GAHKC,SAAwB,IAAIC,IAI3CD,KAAKD,KAAOA,EAoBhB,OAjBEG,gBAAA,SAAIC,EAAkBC,GACpBJ,KAAKK,IAAIC,IAAIH,EAAWH,KAAKD,KAAMK,IAGrCF,gBAAA,SAAIC,GACF,OAAOH,KAAKK,IAAIE,IAAIJ,EAAWH,KAAKD,OAAS,GAG/CG,qBAAA,WAGE,IAFA,IAAMM,EAAM,GAEHC,EAAI,EAAGA,EAAIT,KAAKD,KAAMU,IAC7BD,EAAIE,KAAKV,KAAKO,IAAIE,IAGpB,OAAOD,EAAIG,KAAK,uBCjBlB,WAAYZ,EAAca,GACxBZ,KAAKa,OAAS,IAAIX,EAAOH,GACzBC,KAAKY,KAAOA,EAYhB,OATEE,gBAAA,SAAIC,GAAJ,WACEf,KAAKY,KAAKI,QAAQ,SAAAJ,GAChBK,EAAKJ,OAAOP,IAAIM,EAAKG,GAAO,MAIhCD,gBAAA,SAAIC,GAAJ,WACE,OAAQf,KAAKY,KAAKM,KAAK,SAAAN,GAAQ,OAAgC,IAAhCK,EAAKJ,OAAON,IAAIK,EAAKG"}