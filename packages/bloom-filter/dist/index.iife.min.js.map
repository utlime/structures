{"version":3,"file":"index.iife.min.js","sources":["../src/BitSet.ts","../src/BloomFilter.ts"],"sourcesContent":["type Bit = 0 | 1;\n\nexport class BitSet {\n  private readonly map: Map<number, Bit> = new Map();\n  private readonly size: number;\n\n  constructor(size: number) {\n    this.size = size;\n  }\n\n  set(position: number, value: Bit) {\n    this.map.set(position % this.size, value);\n  }\n\n  get(position: number): Bit {\n    return this.map.get(position % this.size) || 0;\n  }\n\n  toString(): string {\n    const str = [];\n\n    for (let i = 0; i < this.size; i++) {\n      str.push(this.get(i));\n    }\n\n    return str.join('');\n  }\n}\n","import { BitSet } from './BitSet';\nimport { IBloomFilter } from './IBloomFilter';\n\nexport class BloomFilter<T> implements IBloomFilter<T> {\n  private readonly bitSet: BitSet;\n\n  private readonly hash: Array<(item: T) => number>;\n\n  constructor(size: number, hash: Array<(item: T) => number>) {\n    this.bitSet = new BitSet(size);\n    this.hash = hash;\n  }\n\n  add(item: T): void {\n    this.hash.forEach(hash => {\n      this.bitSet.set(hash(item), 1);\n    });\n  }\n\n  has(item: T): boolean {\n    return !this.hash.some(hash => this.bitSet.get(hash(item)) === 0);\n  }\n}\n"],"names":["BitSet","[object Object]","size","this","Map","position","value","map","set","get","str","i","push","join","hash","bitSet","item","forEach","some"],"mappings":"qDAEaA,EAIXC,YAAYC,GAHKC,SAAwB,IAAIC,IAI3CD,KAAKD,KAAOA,EAGdD,IAAII,EAAkBC,GACpBH,KAAKI,IAAIC,IAAIH,EAAWF,KAAKD,KAAMI,GAGrCL,IAAII,GACF,OAAOF,KAAKI,IAAIE,IAAIJ,EAAWF,KAAKD,OAAS,EAG/CD,WACE,MAAMS,EAAM,GAEZ,IAAK,IAAIC,EAAI,EAAGA,EAAIR,KAAKD,KAAMS,IAC7BD,EAAIE,KAAKT,KAAKM,IAAIE,IAGpB,OAAOD,EAAIG,KAAK,gCCjBlBZ,YAAYC,EAAcY,GACxBX,KAAKY,OAAS,IAAIf,EAAOE,GACzBC,KAAKW,KAAOA,EAGdb,IAAIe,GACFb,KAAKW,KAAKG,QAAQH,IAChBX,KAAKY,OAAOP,IAAIM,EAAKE,GAAO,KAIhCf,IAAIe,GACF,OAAQb,KAAKW,KAAKI,KAAKJ,GAAwC,IAAhCX,KAAKY,OAAON,IAAIK,EAAKE"}