var UtlimeAsyncConcurrentLimit=function(s,e,t){"use strict";class r{constructor(s){this.limit=s,this.active=new Set,this.process=null}add(s,e){const t=this.schedule(s,e);return this.runProcess(),t}runTask(s){const e=s();return this.active.add(e),e.finally(()=>this.active.delete(e)),e}runTasks(){let s;for(;this.active.size<this.limit&&null!=(s=this.pull());)this.runTask(s)}schedule(s,e){return new Promise(t=>{this.push(()=>{const e=s();return t(e),e},e)})}runProcess(){if(null==this.process){const s=()=>(this.runTasks(),0===this.active.size?Promise.resolve():Promise.race(this.active).then(s,s));this.process=Promise.resolve().then(s).finally(()=>{this.process=null})}else Promise.resolve().then(()=>this.runTasks())}}return s.AsyncConcurrentStack=class extends r{constructor(s){super(s),this.stack=new e.Stack}push(s){this.stack.push(s)}pull(){return this.stack.pop()}},s.AsyncConcurrentQueue=class extends r{constructor(s){super(s),this.queue=new t.Queue}push(s){this.queue.enqueue(s)}pull(){return this.queue.dequeue()}},s}({},UtlimeStack,UtlimeQueue);
//# sourceMappingURL=index.iife.min.js.map
