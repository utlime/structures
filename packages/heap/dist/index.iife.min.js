var UtlimeHeap=function(t){"use strict";class s{constructor(){this.storage=[]}push(t){this.storage.push(t)}pop(){return this.storage.pop()}swap(t,s){[this.storage[t],this.storage[s]]=[this.storage[s],this.storage[t]]}value(t){return this.storage[t]}parent(t){const s=Math.floor((t-1)/2);return this.exists(s)?s:void 0}left(t){const s=2*t+1;return this.exists(s)?s:void 0}right(t){const s=2*t+2;return this.exists(s)?s:void 0}root(){return this.storage.length>0?0:void 0}tail(){return this.storage.length>0?this.storage.length-1:void 0}exists(t){return t>=0&&t<this.storage.length}}class r{constructor(t){this.storage=new s,this.comparator=null!=t?t:({priority:t},{priority:s})=>t>=s}extract(){const t=this.storage.root(),s=this.storage.tail();null!=t&&null!=s&&this.storage.swap(t,s);const r=this.storage.pop();let e=this.storage.root();for(;null!=e;){const t=this.storage.left(e),s=this.storage.right(e);let r;null==s||null==t||this.compare(t,s)?null!=t&&(r=t):r=s,null==r||this.compare(e,r)?e=void 0:(this.storage.swap(e,r),e=r)}return null!=r?r.item:void 0}insert(t,s){this.storage.push({item:t,priority:s});let r=this.storage.tail(),e=this.storage.parent(r);for(;null!=e&&!this.compare(e,r);)this.storage.swap(r,e),r=e,e=this.storage.parent(r)}compare(t,s){return this.comparator(this.storage.value(t),this.storage.value(s))}}return t.BinaryHeap=r,t.MinHeap=class{constructor(){this.heap=new r(({priority:t},{priority:s})=>t<=s)}insert(t,s){this.heap.insert(t,s)}extract(){return this.heap.extract()}},t.MaxHeap=class{constructor(){this.heap=new r}insert(t,s){this.heap.insert(t,s)}extract(){return this.heap.extract()}},t}({});
//# sourceMappingURL=index.iife.min.js.map
